# Hell-o-world Java-8 세미나 문제풀이

### 1,2 챕터 문제
1, 2 챕터에서 설명된 지식만을 이용해서 아래 코드를 어떻게든 함수형 스타일로 바꿔봅시다.
꼭 아래 알고리즘에서 변형할 필요는 없고, 다른 알고리즘으로 구현해도 상관없습니다.

거꾸로 읽어도 같은 단어인지 확인하는 코드입니다.
wow, level, AOA, I.O.I 같은 단어를 찾는것이지요.

java-7까지는 이런식으로 구현했습니다.
이게 함수형 스타일로 잘 될지는 모르겠는데, 삽질을 해보는 것에 의의를 두겠습니다.

```java
boolean isTextPalindrome(@NonNull String text) {
    int left = 0;
    int right = text.length() - 1;
    while (left < right) {
        if (text.charAt(left++) != text.charAt(right--)) {
            return false;
        }
    }
    return true;
}
```

### 3 챕터 문제
주어진 샘플 파일(1.txt, 2.txt, 3.txt)에 있는 이메일 정보를 통해  
각 도메인별 몇명의 사용자가 이용중인지를 출력 하시오.    
flatmap 도 이용하면 좋을 것 같습니다.(파일을 나눠 보았습니다.)  

### 4 챕터 문제
각종 재료를 첨가하여 원하는 비빔밥을 만드려고 합니다.
아래의 코드 예시처럼 원하는 재료들을 추가해서 비비면 
비빔밥이 완성되도록 데코레이터 패턴을 이용하여 출력해 봅시다.

> Bibimbap bibimbap = new Bibimbap();

> bibimbap.addMaterial(재료::콩나물, 재료::고추장);

> System.out.println(bibimbap.mix());

완성된 비빔밥에 대한 출력은 다음과 같이 나열해 봅니다.
> "재료명1 재료명2 ... 비빔밥"

콩나물, 고추장 추가
> 콩나물 고추장 비빔밥

참지, 마요네즈, 스팸 추가
> 참치 마요네즈 스팸 비빔밥


### 5 챕터 문제
양상현은 걸그룹 여자친구의 공연을 담당하는 담당자입니다.
양상현 담당자는 여자친구의 공연을 축하하기 위해 girl이라는 단어가 들어간 사용자의 이메일을 가진 사람에게
선물을 제공하려고 합니다.

하지만, 양상현 담당자가 랜섬웨어에 감염되어, 당첨자가 들어있는 파일을 잃어버렸고, 날짜별로 정리된 txt파일만 존재합니다.
그래서 양상현 담당자는 스터디를 통해 배운 JAVA8 람다를 통해 당첨자를 선정하려고 합니다.


추첨자 조건
1. 미성년자는 선물 지급에 문제가 있기때문에 20세 이상만 추첨을 해야한다.
2. 이메일에서 아이디를 추출해서 아이디에 girl이 있는 사용자만 대상으로 한다
3. 같은 이메일을 사용하고 이름만 다르게 한 사용자는 잘못된 사용자로 취급하여 대상에서 제외 한다.

위의 조건으로 당첨자가 선정되고 나면 
그분들에게 감사의 카드를 인쇄해서 드리기 위해, {아이디}.txt로 파일을 생성하여 
아래의 내용을 넣어주세요.


==메세지 내용==
000(여기에 이름이 들어가도록)님 안녕하세요
당첨을 축하합니다! 

### 6 챕터 문제
스트림형 피보나치수열을 구현하고 숫자가 100000이상이고 소수인 첫번째 수를 프린트하시오.

### 7 챕터 문제

1,000~100,000,000 그램짜리 거대 아이스크림이 있다. 아이스크림을 한번 핥을때마다 현재 질량의 1/1000이 줄어들며, 남은 아이스크림이 10그램보다 낮을 때 다 먹었다고 본다. 아이스크림을 몇 번 핥아야 다 먹을 수 있는지를 구하는 프로그램을 테일콜 최적화를 활용하여 작성하여라.

+) 책에 나온 TailCall, TailCalls 소스는 함께 올려두었습니다.

### 7,8 챕터 문제 
1949년 인도 수학자 Kaprekar는 Kaprekar 연산을 고안해냈다. Kaprekar 연산은 네 자리 수 중 모든 자리수가 같지 않은 수(1111, 2222 등을 제외한)의 각 자리 의 숫자를 재배열해서 만들 수 있는 가장 큰 수와 가장 작은 수를 만들어서 그 차이를 계산하는데, 그 결과로 나온 새로운 숫자를 갖고 같은 과정을 반복하는 것이다. 간단한 연산이지만 Kaprekar는 이 연산이 놀라운 결과를 보여준다는 것을 발견 했다. 올해 연도인 2008로 그 결과를 알아보자. 2008로 만들 수 있는 가장 큰 수는 8200이고 가장 작은 수는 0028이다.

8200 – 0028 = 8172 8721 – 1278 = 7443 7443 – 3447 = 3996 9963 – 3699 = 6264 6642 – 2466 = 4176 7641 – 1467 = 6174 7641 – 1467 = 6174

6174에 도달한 다음에는 매번 6174를 만들어 낸다. 2008만이 유독 6174에 도달하는 것이 아니라 한 숫자로 이루어지지 않은 모든 네 자리 수는 Kaprekar 연산 을 통해 6174로 가게 된다. 2008의 경우 6 단계를 거쳐 6174로 가게 되었는데, 다른 숫자가 입력으로 주어졌을 때 몇 단계 만에 6174로 가는지 알아내는 프로 그램을 작성하시오.

입력 1000<= N <= 9999 의 int 스트림을 선언하고, Kaprekar수 6174에 해당하는 count중에 가장 큰 count값을 출력한다. 단, 같은수 1111, 2222등과 같은 숫자는 필터를 통해 제외한다.

참고 https://ko.wikipedia.org/wiki/카프리카_상수
---
결과는 {본인 이름}.java로 올려주세요.
