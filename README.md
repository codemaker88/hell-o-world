# Hell-o-world Java-8 세미나 문제풀이

### 1,2 챕터 문제
1, 2 챕터에서 설명된 지식만을 이용해서 아래 코드를 어떻게든 함수형 스타일로 바꿔봅시다.
꼭 아래 알고리즘에서 변형할 필요는 없고, 다른 알고리즘으로 구현해도 상관없습니다.

거꾸로 읽어도 같은 단어인지 확인하는 코드입니다.
wow, level, AOA, I.O.I 같은 단어를 찾는것이지요.

java-7까지는 이런식으로 구현했습니다.
이게 함수형 스타일로 잘 될지는 모르겠는데, 삽질을 해보는 것에 의의를 두겠습니다.

```java
boolean isTextPalindrome(@NonNull String text) {
    int left = 0;
    int right = text.length() - 1;
    while (left < right) {
        if (text.charAt(left++) != text.charAt(right--)) {
            return false;
        }
    }
    return true;
}
```

### 3 챕터 문제
주어진 샘플 파일(1.txt, 2.txt, 3.txt)에 있는 이메일 정보를 통해  
각 도메인별 몇명의 사용자가 이용중인지를 출력 하시오.    
flatmap 도 이용하면 좋을 것 같습니다.(파일을 나눠 보았습니다.)  

### 4 챕터 문제
각종 재료를 첨가하여 원하는 비빔밥을 만드려고 합니다.
아래의 코드 예시처럼 원하는 재료들을 추가해서 비비면 
비빔밥이 완성되도록 데코레이터 패턴을 이용하여 출력해 봅시다.

> Bibimbap bibimbap = new Bibimbap();

> bibimbap.addMaterial(재료::콩나물, 재료::고추장);

> System.out.println(bibimbap.mix());

완성된 비빔밥에 대한 출력은 다음과 같이 나열해 봅니다.
> "재료명1 재료명2 ... 비빔밥"

콩나물, 고추장 추가
> 콩나물 고추장 비빔밥

참지, 마요네즈, 스팸 추가
> 참치 마요네즈 스팸 비빔밥


### 5 챕터 문제
양상현은 걸그룹 여자친구의 공연을 담당하는 담당자입니다.
양상현 담당자는 여자친구의 공연을 축하하기 위해 girl이라는 단어가 들어간 사용자의 이메일을 가진 사람에게
선물을 제공하려고 합니다.

하지만, 양상현 담당자가 랜섬웨어에 감염되어, 당첨자가 들어있는 파일을 잃어버렸고, 날짜별로 정리된 txt파일만 존재합니다.
그래서 양상현 담당자는 스터디를 통해 배운 JAVA8 람다를 통해 당첨자를 선정하려고 합니다.


추첨자 조건
1. 미성년자는 선물 지급에 문제가 있기때문에 20세 이상만 추첨을 해야한다.
2. 이메일에서 아이디를 추출해서 아이디에 girl이 있는 사용자만 대상으로 한다
3. 같은 이메일을 사용하고 이름만 다르게 한 사용자는 잘못된 사용자로 취급하여 대상에서 제외 한다.

위의 조건으로 당첨자가 선정되고 나면 
그분들에게 감사의 카드를 인쇄해서 드리기 위해, {아이디}.txt로 파일을 생성하여 
아래의 내용을 넣어주세요.


==메세지 내용==
000(여기에 이름이 들어가도록)님 안녕하세요
당첨을 축하합니다! 

### 6 챕터 문제
스트림형 피보나치수열을 구현하고 숫자가 100000이상이고 소수인 첫번째 수를 프린트하시오.

### 7 챕터 문제

1,000~100,000,000 그램짜리 거대 아이스크림이 있다. 아이스크림을 한번 핥을때마다 현재 질량의 1/1000이 줄어들며, 남은 아이스크림이 10그램보다 낮을 때 다 먹었다고 본다. 아이스크림을 몇 번 핥아야 다 먹을 수 있는지를 구하는 프로그램을 테일콜 최적화를 활용하여 작성하여라.

+) 책에 나온 TailCall, TailCalls 소스는 함께 올려두었습니다.

### 8,9 챕터 문제 
1949년 인도 수학자 Kaprekar는 Kaprekar 연산을 고안해냈다. Kaprekar 연산은 네 자리 수 중 모든 자리수가 같지 않은 수(1111, 2222 등을 제외한)의 각 자리 의 숫자를 재배열해서 만들 수 있는 가장 큰 수와 가장 작은 수를 만들어서 그 차이를 계산하는데, 그 결과로 나온 새로운 숫자를 갖고 같은 과정을 반복하는 것이다. 간단한 연산이지만 Kaprekar는 이 연산이 놀라운 결과를 보여준다는 것을 발견 했다. 올해 연도인 2008로 그 결과를 알아보자. 2008로 만들 수 있는 가장 큰 수는 8200이고 가장 작은 수는 0028이다.

```java
8200 – 0028 = 8172 
8721 – 1278 = 7443 
7443 – 3447 = 3996 
9963 – 3699 = 6264 
6642 – 2466 = 4176 
7641 – 1467 = 6174 
7641 – 1467 = 6174
```

6174에 도달한 다음에는 매번 6174를 만들어 낸다. 2008만이 유독 6174에 도달하는 것이 아니라 한 숫자로 이루어지지 않은 모든 네 자리 수는 Kaprekar 연산 을 통해 6174로 가게 된다. 2008의 경우 6 단계를 거쳐 6174로 가게 되었는데, 다른 숫자가 입력으로 주어졌을 때 몇 단계 만에 6174로 가는지 알아내는 프로 그램을 작성하시오.

입력 1000<= N <= 9999 의 int 스트림을 선언하고, Kaprekar수 6174에 해당하는 count중에 가장 큰 count값을 출력한다. 단, 같은수 1111, 2222등과 같은 숫자는 필터를 통해 제외한다.

참고 https://ko.wikipedia.org/wiki/카프리카_상수

### 추가 문제1
콜라츠 추측 (Collatz conjecture)은 1937년에 처음으로 이 추측을 제기한 로타르 콜라츠의 이름을 딴 것으로 3n+1 추측, 울람 추측, 혹은 헤일스톤(우박) 수열 등 여러 이름으로 불린다. 콜라츠 추측은 임의의 자연수가 다음 조작을 거쳐 항상 1이 된다는 추측이다.

짝수라면 2로 나눈다.
홀수라면 3을 곱하고 1을 더한다.
1이면 조작을 멈추고, 1이 아니면 첫 번째 단계로 돌아간다.
예를 들어, 6 에서 시작한다면, 차례로 6, 3, 10, 5, 16, 8, 4, 2, 1 이 된다.

참고 : https://ko.wikipedia.org/wiki/%EC%BD%9C%EB%9D%BC%EC%B8%A0_%EC%B6%94%EC%B8%A1

어떤 자연수에 대해서 몇번의 과정의 거쳐야 1이 되는지를 푸는 문제는 너무 쉽다.

따라서, 수금의 확률을 높이기 위해 새로운 개념을 도입하기로 한다.

* 어떤 자연수 n이 1이 될 때 까지 필요한 과정의 수를 depth라고 할 때, depth가 같은 자연수 n들을 서로 친구인 수라고 정의하기로 한다.

* 예를 들어, 6의 depth는 9, depth 9에서의 친구는 4명이다. { 6, 40, 42, 256 }

문제 : depth을 하나씩 늘려가면서 친구의 수를 출력하면, 또다른 형태의 수열이 나옵니다.
누가 먼저 이름 붙이지 않았다면, 종혁수열이라고 부르겠습니다. 
40까지의 종혁수열을 출력해봅시다. (대략 5초 내에 결과가 나와야 합니다. 1초 내에 나오면 더 좋고...)

출력 되어야 하는 정답 :  1, 1, 1, 1, 2, 2, 4, 4, 6, 6, 8, 10, 14, 18, 24, 29, 36, 44, 58, 72, 91, 113, 143, 179, 227, 287, 366, 460, 578, 732, 926, 1174, 1489, 1879, 2365, 2988, 3780, 4788, 6049, ...

### 추가 문제2
총잡이 게임

N명의 시민이 있고, 그중 M명은 무법자이며, 1명은 정신병자이다. 이들은 원의 형태로 둘러앉아있으며 자리 배치는 배열로 주어진다. N명의 사람들은 시계방향으로 자기 차례를 갖게 되는데 이 때 다음과 같이 행동한다.

시민
양 옆 사람중 살인자 카운트가 높은 사람을 쏜다. (죽은 사람은 없는것으로 친다)
양 옆 사람의 살인자카운트가 같을 경우 쏘지 않는다.
사람을 쏠 때 마다 살인자카운트가 높아진다.

무법자

양 옆 사람중 살인자 카운트가 낮은 사람을 쏜다.
양 옆 사람의 살인자 카운트가 같을 경우 자신의 왼쪽사람을 쏜다.
무법자는 서로 쏘지 않는다. (위 조건에 해당하더라도 항상 무법자가 없는 방향을 쏜다)
사람을 쏠 때 마다 살인자카운트가 높아진다.

정신병자

남은 사람이 짝수일 경우 자신을 기준으로 맞은편에 있는 사람을 쏜다.
남은 사람이 홀수일 경우 자기 자신을 쏜다. (혼자남은 경우 제외)
살인자카운트가 올라가지 않는다.
무법자가 모두 죽었을 경우. '시민 승리'와 시민이 몇 명 살아남았는지를 출력하라. 무법자만 살아남았을 경우. '무법자 승리'와 무법자가 몇 명 살아남았는지를 출력하라. 정신병자만 살아남았을 경우. '정신병자 승리'를 출력하라.

---
결과는 {본인 이름}.java로 올려주세요.
